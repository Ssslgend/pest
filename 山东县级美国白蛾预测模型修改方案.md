# 山东县级美国白蛾预测模型修改方案

## 项目概述
现有BiLSTM模型需要从点级别预测升级到山东省县级尺度的美国白蛾风险预测。

## 问题分析
### 当前问题
1. **预测尺度不匹配**：当前模型适合时间序列点预测，但需要县级空间预测
2. **特征维度不足**：input_size=12，不足以支持县级多维度特征
3. **缺乏空间关系**：没有考虑县级之间的空间邻接关系
4. **数据结构不适应**：当前训练数据是水稻害虫，不是美国白蛾

### 目标
- 预测山东省137个县级单位的美国白蛾发生风险
- 输出每个县的风险等级（0-3级）和发生概率
- 考虑时间序列特征和空间传播特征

---

## 📊 数据结构调整方案

### 输入数据格式修改

#### 原始数据格式（示例）
```csv
county_name,year,month,occurrence_status
济南历下区,2023,1,0
济南历下区,2023,2,1
青岛市南区,2023,1,0
```

#### 目标数据格式（30维特征）
```csv
county_id,county_name,year,month,avg_temp,precipitation,humidity,ndvi,population,forest_coverage,elevation,latitude,longitude,neighboring_risk,historical_occurrence,target
370101,历下区,2023,1,2.5,10.2,65.3,0.45,1500000,0.35,120.5,36.7,0.15,0,0
370102,市中区,2023,1,1.8,8.5,62.1,0.42,1200000,0.28,118.3,36.2,0.12,1,1
```

### 特征维度扩展（30维）

#### 1. 气象特征（8维）
- avg_temp: 月平均温度
- max_temp: 月最高温度  
- min_temp: 月最低温度
- precipitation: 月降水量
- humidity: 相对湿度
- wind_speed: 风速
- sunshine: 日照时数
- pressure: 气压

#### 2. 地理特征（4维）
- elevation: 海拔高度
- slope: 坡度
- latitude: 纬度
- longitude: 经度

#### 3. 植被特征（3维）
- ndvi: 归一化植被指数
- evi: 增强植被指数
- forest_coverage: 森林覆盖率

#### 4. 社会经济特征（3维）
- population: 人口数量
- gdp: 地区生产总值
- agricultural_area: 农业用地面积

#### 5. 历史特征（2维）
- historical_occurrence: 历史发生次数
- neighboring_risk: 邻接县风险指数

#### 6. 时间特征（2维）
- month: 月份（1-12）
- season: 季节（1-4）

#### 7. 县级嵌入特征（8维）
- 通过Embedding层学习县级特有特征

### 空间邻接矩阵构建

```python
# 山东县级邻接关系示例
adjacency_matrix = {
    370101: [370102, 370103, 370112],  # 历下区相邻县
    370102: [370101, 370103, 370105],  # 市中区相邻县
    # ... 所有137个县的邻接关系
}

# 邻接矩阵计算方式
def calculate_adjacency(county_coords, threshold=50):
    """
    county_coords: {county_id: (lat, lon)}
    threshold: 邻接距离阈值（公里）
    """
    adjacency = {}
    for county1, coord1 in county_coords.items():
        neighbors = []
        for county2, coord2 in county_coords.items():
            if county1 != county2:
                distance = haversine(coord1, coord2)
                if distance <= threshold:
                    neighbors.append(county2)
        adjacency[county1] = neighbors
    return adjacency
```

---

## 🎯 模型预测输出格式

### 输出1: 风险等级预测
```python
# 每个县的风险等级（0-3）
output = {
    'county_id': [370101, 370102, 370103, ...],
    'county_name': ['历下区', '市中区', '槐荫区', ...],
    'risk_level': [0, 1, 2, 0, 3, 1, ...],  # 0:无风险, 1:低风险, 2:中风险, 3:高风险
    'probability': [0.1, 0.3, 0.6, 0.2, 0.9, 0.4, ...],  # 风险概率
    'prediction_month': '2024-06'
}
```

### 输出2: 发生概率预测
```python
# 每个县的发生概率（0-1）
output = {
    'county_predictions': {
        '370101': {'name': '历下区', 'probability': 0.15, 'risk': 'low'},
        '370102': {'name': '市中区', 'probability': 0.75, 'risk': 'high'},
        '370103': {'name': '槐荫区', 'probability': 0.45, 'risk': 'medium'},
        # ... 所有137个县
    },
    'prediction_date': '2024-06-01',
    'model_version': 'county_level_v1'
}
```

### 输出3: 空间分布可视化数据
```python
# 可视化输出
output = {
    'map_data': {
        'counties': [所有县的多边形数据],
        'risk_values': [每个县的风险值],
        'color_scale': 'green_to_red'
    },
    'summary': {
        'high_risk_counties': 15,
        'medium_risk_counties': 32,
        'low_risk_counties': 45,
        'no_risk_counties': 45
    }
}
```

### 风险等级定义
- **0级（无风险）**：发生概率 < 0.2
- **1级（低风险）**：0.2 ≤ 发生概率 < 0.4
- **2级（中风险）**：0.4 ≤ 发生概率 < 0.7
- **3级（高风险）**：发生概率 ≥ 0.7

---

## 🏗️ 模型架构修改方案

### 方案1: 空间增强型BiLSTM（推荐）

**核心思路**：保留BiLSTM的时间序列能力，增加空间特征和县级注意力

```python
import torch
import torch.nn as nn
import torch.nn.functional as F

class CountyLevelBiLSTM(nn.Module):
    def __init__(self, config):
        super().__init__()
        
        # 特征维度
        self.input_size = 30  # 扩展后的特征维度
        self.county_count = 137  # 山东县级数量
        self.hidden_size = 256
        self.num_classes = 4
        
        # 1. 县级嵌入层（学习每个县的特有特征）
        self.county_embedding = nn.Embedding(self.county_count, 16)
        
        # 2. 特征编码器
        self.feature_encoder = nn.Sequential(
            nn.Linear(self.input_size + 16, 128),  # +16是县级嵌入
            nn.ReLU(),
            nn.Dropout(0.3),
            nn.Linear(128, 64)
        )
        
        # 3. 时间序列BiLSTM
        self.lstm = nn.LSTM(
            input_size=64,
            hidden_size=self.hidden_size,
            num_layers=3,
            batch_first=True,
            bidirectional=True,
            dropout=0.3
        )
        
        # 4. 空间注意力机制
        self.spatial_attention = nn.MultiheadAttention(
            embed_dim=self.hidden_size * 2,
            num_heads=8,
            dropout=0.1
        )
        
        # 5. 输出层
        self.classifier = nn.Sequential(
            nn.Linear(self.hidden_size * 2, 128),
            nn.ReLU(),
            nn.Dropout(0.3),
            nn.Linear(128, self.num_classes)
        )
        
    def forward(self, features, county_ids, spatial_adjacency):
        """
        features: [batch_size, seq_len, input_size]
        county_ids: [batch_size] 县级ID
        spatial_adjacency: [batch_size, batch_size] 空间邻接矩阵
        """
        batch_size, seq_len, _ = features.shape
        
        # 1. 添加县级嵌入
        county_emb = self.county_embedding(county_ids)  # [batch_size, 16]
        county_emb = county_emb.unsqueeze(1).expand(-1, seq_len, -1)  # [batch_size, seq_len, 16]
        
        # 2. 特征融合
        combined_features = torch.cat([features, county_emb], dim=-1)
        encoded_features = self.feature_encoder(combined_features)  # [batch_size, seq_len, 64]
        
        # 3. 时间序列处理
        lstm_out, _ = self.lstm(encoded_features)  # [batch_size, seq_len, hidden_size*2]
        
        # 4. 空间注意力
        spatial_out, _ = self.spatial_attention(
            lstm_out[:, -1, :].unsqueeze(0),  # 取最后一个时间步
            lstm_out[:, -1, :].unsqueeze(0),
            lstm_out[:, -1, :].unsqueeze(0)
        )
        spatial_out = spatial_out.squeeze(0)  # [batch_size, hidden_size*2]
        
        # 5. 最终分类
        output = self.classifier(spatial_out)  # [batch_size, num_classes]
        
        return output
```

### 方案2: 图神经网络（GCN）

**优势**：专门处理空间关系，适合县级尺度

```python
import torch_geometric.nn as pyg_nn

class CountyGCN(nn.Module):
    def __init__(self, num_counties, input_dim, hidden_dim, num_classes):
        super().__init__()
        
        # 图卷积层
        self.conv1 = pyg_nn.GCNConv(input_dim, hidden_dim)
        self.conv2 = pyg_nn.GCNConv(hidden_dim, hidden_dim // 2)
        self.conv3 = pyg_nn.GCNConv(hidden_dim // 2, num_classes)
        
        # 县级特征
        self.county_embeddings = nn.Parameter(torch.randn(num_counties, input_dim))
        
    def forward(self, edge_index, features=None):
        """
        edge_index: 图的边连接 [2, num_edges]
        features: 可选的外部特征
        """
        if features is not None:
            x = torch.cat([self.county_embeddings, features], dim=-1)
        else:
            x = self.county_embeddings
            
        x = F.relu(self.conv1(x, edge_index))
        x = F.dropout(x, p=0.3, training=self.training)
        x = F.relu(self.conv2(x, edge_index))
        x = self.conv3(x, edge_index)
        
        return F.log_softmax(x, dim=1)
```

### 方案3: 集成模型（最准确）

```python
class CountyEnsembleModel(nn.Module):
    def __init__(self, config):
        super().__init__()
        
        # 1. BiLSTM分支（时间特征）
        self.temporal_model = CountyLevelBiLSTM(config)
        
        # 2. GCN分支（空间特征）
        self.spatial_model = CountyGCN(
            num_counties=config['num_counties'],
            input_dim=config['spatial_input_dim'],
            hidden_dim=config['hidden_size'],
            num_classes=config['num_classes']
        )
        
        # 3. 集成层
        self.ensemble = nn.Linear(config['num_classes'] * 2, config['num_classes'])
        
    def forward(self, temporal_features, county_ids, edge_index, spatial_features):
        # 时间分支
        temporal_output = self.temporal_model(temporal_features, county_ids, edge_index)
        
        # 空间分支  
        spatial_output = self.spatial_model(edge_index, spatial_features)
        
        # 集成
        combined = torch.cat([temporal_output, spatial_output], dim=-1)
        final_output = self.ensemble(combined)
        
        return final_output
```

---

## 🎯 具体实施方案

### 步骤1: 数据准备

1. **构建县级特征表**（30维特征）
   - 气象数据来源：国家气象局、ECMWF再分析数据
   - 地理数据来源：SRTM高程数据、山东地理信息数据
   - 植被数据来源：MODIS NDVI/EVI数据
   - 社会经济数据：山东统计年鉴

2. **数据预处理**
   ```python
   def preprocess_county_data(raw_data):
       """
       预处理县级数据
       """
       # 标准化数值特征
       scaler = StandardScaler()
       numerical_features = ['avg_temp', 'precipitation', 'population', ...]
       raw_data[numerical_features] = scaler.fit_transform(raw_data[numerical_features])
       
       # 编码分类特征
       raw_data['season'] = raw_data['month'].apply(get_season)
       
       # 计算邻域风险
       raw_data['neighboring_risk'] = calculate_neighboring_risk(
           raw_data, adjacency_matrix
       )
       
       return raw_data
   ```

### 步骤2: 模型配置

```python
# 更新配置文件 config/params.py
COUNTY_MODEL_CONFIG = {
    "input_size": 30,           # 扩展特征维度
    "hidden_size": 256,         # 隐藏层大小
    "num_layers": 3,            # 模型层数
    "num_classes": 4,           # 4个风险等级
    "dropout": 0.3,             # Dropout率
    "county_count": 137,        # 山东县级数量
    "county_embedding_dim": 16, # 县级嵌入维度
    "spatial_attention": True,   # 空间注意力
    "model_type": "enhanced_lstm"  # 模型类型
}

COUNTY_TRAIN_CONFIG = {
    "batch_size": 32,           # 批次大小
    "num_epochs": 200,          # 训练轮数
    "learning_rate": 0.001,     # 学习率
    "seq_length": 12,           # 12个月时间序列
    "patience": 15,             # 早停耐心值
    "weight_decay": 1e-4,       # 权重衰减
}
```

### 步骤3: 训练策略

```python
# 训练数据格式
train_data = {
    'features': torch.tensor([[[30维特征]]]),  # [batch_size, seq_len, input_size]
    'county_ids': torch.tensor([370101, 370102, ...]),  # 县级ID
    'labels': torch.tensor([0, 1, 2, 0, 3, ...]),  # 风险等级
    'spatial_adjacency': adjacency_matrix  # 空间关系
}

# 训练循环
def train_county_model(model, train_loader, optimizer, criterion):
    model.train()
    total_loss = 0
    
    for batch in train_loader:
        features = batch['features']
        county_ids = batch['county_ids']
        labels = batch['labels']
        adjacency = batch['adjacency']
        
        optimizer.zero_grad()
        outputs = model(features, county_ids, adjacency)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()
        
        total_loss += loss.item()
    
    return total_loss / len(train_loader)
```

### 步骤4: 预测函数

```python
def predict_shandong_counties(model, date_features, adjacency_matrix):
    """
    预测整个山东省各县的美国白蛾风险
    
    Args:
        model: 训练好的模型
        date_features: 指定时间特征（月度气象数据等）
        adjacency_matrix: 县级邻接矩阵
    
    Returns:
        predictions: 包含137个县预测结果的字典
    """
    model.eval()
    predictions = {}
    
    for county_id in range(370101, 370101 + 137):  # 山东县级ID范围
        # 准备该县的输入特征
        county_features = prepare_county_features(county_id, date_features)
        
        # 模型预测
        with torch.no_grad():
            output = model(
                county_features.unsqueeze(0),  # 添加batch维度
                torch.tensor([county_id]),
                adjacency_matrix
            )
            risk_prob = F.softmax(output, dim=-1)
            risk_level = torch.argmax(risk_prob)
        
        predictions[county_id] = {
            'risk_level': risk_level.item(),
            'probability': risk_prob.max().item(),
            'county_name': get_county_name(county_id),
            'risk_probabilities': risk_prob.squeeze().tolist()
        }
    
    return predictions

def generate_risk_map(predictions):
    """
    生成风险等级可视化
    """
    risk_map = {
        'high_risk': [],
        'medium_risk': [], 
        'low_risk': [],
        'no_risk': []
    }
    
    for county_id, pred in predictions.items():
        risk_level = pred['risk_level']
        if risk_level == 3:
            risk_map['high_risk'].append(pred['county_name'])
        elif risk_level == 2:
            risk_map['medium_risk'].append(pred['county_name'])
        elif risk_level == 1:
            risk_map['low_risk'].append(pred['county_name'])
        else:
            risk_map['no_risk'].append(pred['county_name'])
    
    return risk_map
```

---

## 💡 实施建议

### 1. 数据收集优先级
1. **高优先级**：气象数据、历史发生数据、地理坐标
2. **中优先级**：植被指数、人口数据
3. **低优先级**：经济数据、详细地形数据

### 2. 模型选择建议
- **快速实施**：方案1（空间增强型BiLSTM）
- **最佳效果**：方案3（集成模型）
- **研究导向**：方案2（图神经网络）

### 3. 分步实施计划
1. **第1阶段**：数据收集和预处理（2-3周）
2. **第2阶段**：模型架构修改和训练（3-4周）
3. **第3阶段**：预测验证和调优（2-3周）
4. **第4阶段**：可视化和部署（1-2周）

### 4. 验证方法
- **时间序列验证**：使用历史数据验证预测准确性
- **交叉验证**：空间交叉验证验证泛化能力
- **专家评估**：邀请植保专家评估预测结果合理性

### 5. 风险控制
- **数据质量**：确保输入数据的准确性和完整性
- **模型过拟合**：使用早停、正则化、Dropout等技术
- **计算资源**：合理配置GPU内存和计算资源

通过以上修改，你的模型将能够：
- 从点级别预测升级到县级尺度预测
- 同时考虑时间序列特征和空间传播特征
- 输出整个山东省137个县的美国白蛾风险预测
- 提供可视化的风险分布图

这个方案既保留了你现有BiLSTM模型的优势，又增加了空间预测能力，非常适合县级尺度的害虫风险预测任务。